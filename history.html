---
layout: default
title: Charging History
permalink: /history/
---

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
    .summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    .card {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .card h3 {
        color: #667eea;
        font-size: 0.9em;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
    }

    .card .value {
        font-size: 2em;
        font-weight: bold;
        color: #333;
    }

    .controls {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        display: flex;
        gap: 20px;
        align-items: center;
        flex-wrap: wrap;
    }

    .control-group {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .control-group label {
        font-weight: 600;
        color: #333;
    }

    select,
    button {
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
        cursor: pointer;
    }

    button {
        background: #667eea;
        color: white;
        border: none;
    }

    button:hover {
        background: #5568d3;
    }

    button:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .view-buttons {
        display: flex;
        gap: 5px;
    }

    .view-buttons button {
        padding: 6px 12px;
        font-size: 12px;
    }

    .view-buttons button.active {
        background: #333;
    }

    .chart-container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 30px;
    }

    /* Loading spinner */
    .spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .status-message {
        position: fixed;
        top: 80px;
        right: 20px;
        background: white;
        padding: 12px 16px;
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border-left: 4px solid #667eea;
        font-size: 14px;
        z-index: 1000;
        max-width: 400px;
        animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
        from {
            transform: translateX(100%);
            opacity: 0;
        }

        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    @keyframes slideOut {
        from {
            transform: translateX(0);
            opacity: 1;
        }

        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }

    .status-message.loading {
        border-left-color: #667eea;
        color: #333;
    }

    .status-message.info {
        border-left-color: #3b82f6;
        color: #1e40af;
        background: #eff6ff;
    }

    .status-message.warning {
        border-left-color: #f59e0b;
        color: #92400e;
        background: #fffbeb;
    }

    .status-message.error {
        border-left-color: #ef4444;
        color: #7f1d1d;
        background: #fef2f2;
    }

    .chart-container {
        position: relative;
        height: 400px;
    }

    .sessions-table {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        overflow: hidden;
    }

    table {
        width: 100%;
        border-collapse: collapse;
    }

    th {
        background: #f5f5f5;
        padding: 12px;
        text-align: left;
        font-weight: 600;
        color: #333;
        border-bottom: 2px solid #ddd;
    }

    td {
        padding: 12px;
        border-bottom: 1px solid #eee;
    }

    tr:hover {
        background: #f9f9f9;
    }

    .no-data {
        text-align: center;
        padding: 40px;
        color: #999;
    }
</style>

<h2>Charging History</h2>

<div class="controls">
    <div class="control-group">
        <label>Period:</label>
        <button id="prev-btn" onclick="previousPeriod()">← Previous</button>
        <span id="period-label" style="min-width: 150px; text-align: center; font-weight: 600;"></span>
        <button id="next-btn" onclick="nextPeriod()">Next →</button>
    </div>

    <div class="control-group">
        <label>View:</label>
        <div class="view-buttons">
            <button class="view-btn" data-view="day" onclick="changeView('day')">Day</button>
            <button class="view-btn active" data-view="month" onclick="changeView('month')">Month</button>
            <button class="view-btn" data-view="year" onclick="changeView('year')">Year</button>
        </div>
    </div>

    <div class="control-group">
        <label>Vehicle:</label>
        <select id="vehicle-filter" onchange="applyFilters()">
            <option value="all">All Vehicles</option>
            <option value="serenity_equinox_2024">Serenity</option>
            <option value="volvo_xc40_2021">Volvo</option>
            <option value="unknown">Unknown</option>
        </select>
    </div>

    <div class="control-group">
        <label>Metric:</label>
        <select id="metric-filter" onchange="applyFilters()">
            <option value="energy">Energy (kWh)</option>
            <option value="miles">Miles Added</option>
            <option value="sessions">Session Count</option>
        </select>
    </div>
</div>

<div class="summary">
    <div class="card">
        <h3 id="stat1-label">Total Energy</h3>
        <div class="value" id="stat1-value">—</div>
    </div>
    <div class="card">
        <h3 id="stat2-label">Total Miles</h3>
        <div class="value" id="stat2-value">—</div>
    </div>
    <div class="card">
        <h3 id="stat3-label">Sessions</h3>
        <div class="value" id="stat3-value">—</div>
    </div>
</div>

<div class="chart-container">
    <canvas id="sessionChart"></canvas>
</div>

<h3>Session Details</h3>
<div class="sessions-table">
    <table>
        <thead>
            <tr>
                <th>Date/Time</th>
                <th>Vehicle</th>
                <th>Energy (kWh)</th>
                <th>Miles</th>
                <th>Duration</th>
                <th>Location</th>
            </tr>
        </thead>
        <tbody id="sessions-tbody">
            <tr>
                <td class="no-data" colspan="6">Loading...</td>
            </tr>
        </tbody>
    </table>
</div>

<script>
    // State
    let allSessions = [];
    let currentView = 'month'; // day, month, year (default: month)
    let currentDate = new Date();
    let chart = null;
    let vehicleConfig = {};
    let sessionVehicleMap = {};

    // Weighted average efficiency for unknown vehicles is computed by:
    //   1. Summing total kWh delivered for each known vehicle across all sessions.
    //   2. Calculating weighted average: sum(kWh_i * eff_i) / sum(kWh_i)
    //   3. Using this value for unknown vehicles' mileage estimation.
    let weightedAvgEfficiency = 2.5; // fallback if no data

    // No direct ChargePoint API calls from frontend
    // All data comes from GitHub Actions workflows that populate monthly cache files

    async function discoverSessions() {
        /**
         * Load cached session data from GitHub repository.
         * 
         * Monthly cache files are created by GitHub Actions workflow:
         * - Workflow runs fetch_session_details.py 
         * - Creates data/session_cache/YYYY-MM.json with session metrics
         * - Commits to repo
         * 
         * This page loads available cache files and displays them.
         * If a month's cache doesn't exist yet, that month simply has no data.
         */

        // Load vehicle configuration and session vehicle map
        try {
            const response = await fetch(`https://raw.githubusercontent.com/scerruti/cph50-control/main/data/vehicle_config.json?t=${Date.now()}`);
            if (response.ok) {
                const config = await response.json();
                vehicleConfig = config.vehicles || {};
            }
        } catch (e) {
            console.warn('Could not load vehicle config:', e);
        }

        try {
            const response = await fetch(`https://raw.githubusercontent.com/scerruti/cph50-control/main/data/session_vehicle_map.json?t=${Date.now()}`);
            if (response.ok) {
                const map = await response.json();
                sessionVehicleMap = map.sessions || {};
            }
        } catch (e) {
            console.warn('Could not load session vehicle map:', e);
        }

        allSessions = [];

        // Temporary array to collect known vehicle energy for weighted average
        let vehicleEnergyTotals = {};
        let vehicleEfficiencies = {};

        // Try to load monthly cache files for last 13 months
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth() + 1;

        // Generate list of months to try (last 13 months)
        for (let m = 0; m < 13; m++) {
            let year = currentYear;
            let month = currentMonth - m;
            if (month < 1) {
                month += 12;
                year -= 1;
            }

            const monthKey = `${year.toString().padStart(4, '0')}-${month.toString().padStart(2, '0')}`;
            const cachePath = `data/session_cache/${year}/${month.toString().padStart(2, '0')}/${monthKey}.json`;

            try {
                const response = await fetch(`https://raw.githubusercontent.com/scerruti/cph50-control/main/${cachePath}?t=${Date.now()}`);
                if (response.ok) {
                    const sessions = await response.json();
                    if (Array.isArray(sessions)) {
                        for (const session of sessions) {
                            // For weighted average, collect energy by vehicle
                            let sessionId = session.session_id;
                            let vehicleId = sessionVehicleMap[sessionId]?.vehicle || session.vehicle?.id;
                            let energy = session.energy_kwh || 0;
                            if (vehicleId && vehicleId !== 'unknown' && vehicleConfig[vehicleId]) {
                                vehicleEnergyTotals[vehicleId] = (vehicleEnergyTotals[vehicleId] || 0) + energy;
                                vehicleEfficiencies[vehicleId] = vehicleConfig[vehicleId].efficiency_mi_per_kwh;
                            }
                            allSessions.push(parseDetailedSession(session));
                        }
                    }
                }
            } catch (e) {
                // Silently skip missing months
            }
        }

        // Compute weighted average efficiency for unknown vehicles
        let totalKWh = 0, weightedSum = 0;
        for (const [vid, kwh] of Object.entries(vehicleEnergyTotals)) {
            const eff = vehicleEfficiencies[vid];
            if (typeof eff === 'number' && typeof kwh === 'number') {
                weightedSum += kwh * eff;
                totalKWh += kwh;
            }
        }
        if (totalKWh > 0) {
            weightedAvgEfficiency = weightedSum / totalKWh;
        } else {
            weightedAvgEfficiency = 2.5;
        }

        // 1. Sort by start time (Oldest -> Newest)
        allSessions.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));

        // 2. ONE-TIME DATA FIX: Handle missing end times
        if (allSessions.length > 0) {
            // Identify the timestamp of the latest session
            // (Since we just sorted, it's technically the last item, but Math.max is safer if sort changes)
            const latestStartTime = allSessions[allSessions.length - 1].startTime.getTime();

            allSessions.forEach(s => {
                // Only fix sessions where endTime is null
                if (!s.endTime) {
                    if (s.startTime.getTime() === latestStartTime) {
                        // CASE A: It is the latest session -> It is ACTIVE
                        s.endTime = new Date();
                        s.isActive = true;
                        s.duration = Math.round((s.endTime - s.startTime) / 1000 / 60);
                    } else {
                        // CASE B: It is an old session -> It is BROKEN (Zombie)
                        // "Cap" it at the start time so it becomes a Point Event
                        s.endTime = s.startTime;
                        s.isZombie = true;
                        s.duration = 0; // 0 minutes duration
                    }

                    // Update derived field for display
                    s.localEndTime = convertToLocalTime(s.endTime);
                }
            });
        }

        console.log(`Loaded ${allSessions.length} sessions`);
    }

    function getVehicleDisplayName(vehicleId) {
        /**
         * Get the display name for a vehicle based on config.
         * Logic: If vehicle has nickname, use it. Otherwise use model.
         * If two vehicles share the same name and display_color disambiguates, prefix with color.
         */
        if (!vehicleId || vehicleId === 'unknown') return 'Unknown';

        const vehicle = vehicleConfig[vehicleId];
        if (!vehicle) return vehicleId;

        const displayName = vehicle.nickname || vehicle.model;

        // Check if another vehicle has the same display name
        const others = Object.entries(vehicleConfig)
            .filter(([id, _]) => id !== vehicleId)
            .filter(([_, v]) => (v.nickname || v.model) === displayName);

        if (others.length > 0) {
            // Check if display_color can disambiguate
            const sameColor = others.some(([_, v]) => v.display_color === vehicle.display_color);
            if (!sameColor && vehicle.display_color) {
                return `${vehicle.display_color} ${vehicle.model}`;
            }
        }

        return displayName;
    }

    function parseDetailedSession(data) {
        /**
         * Parse minimal session format from monthly cache files
         * Cache contains only: session_id, start_time, end_time, energy, vehicle (id + confidence)
         * Vehicle names and efficiency come from vehicle_config.json
         */
        const startTime = new Date(data.session_start_time || 0);
        const localStartTime = convertToLocalTime(startTime);


        // Just pass the raw value (or null) through. 
        // We will calculate the real 'endTime' in the post-processing step.
        const endTime = data.session_end_time ? new Date(data.session_end_time) : null;

        // Calculate duration from start/end times
        // Duration is null if we don't have an end time
        const duration = endTime ? Math.round((endTime - startTime) / 1000 / 60) : null;

        const sessionId = data.session_id;

        // Get vehicle ID and confidence from cache (already classified)
        let vehicleId = data.vehicle?.id || 'unknown';
        let confidence = data.vehicle?.confidence || 0;

        // Override with session_vehicle_map if it has different confidence/source
        if (sessionVehicleMap[sessionId]) {
            vehicleId = sessionVehicleMap[sessionId].vehicle || vehicleId;
            confidence = sessionVehicleMap[sessionId].confidence || confidence;
        }

        // Get efficiency for miles calculation
        const vehicleConfig_data = vehicleConfig[vehicleId];
        const energy = data.energy_kwh || 0;
        let efficiency;
        if (vehicleId === 'unknown' || !vehicleConfig_data) {
            efficiency = weightedAvgEfficiency;
        } else {
            efficiency = vehicleConfig_data.efficiency_mi_per_kwh || weightedAvgEfficiency;
        }
        const miles = energy * efficiency;

        return {
            id: sessionId,
            startTime: startTime,
            localStartTime: localStartTime,
            endTime: endTime, // May be null
            duration: duration, // in minutes, may be null
            energy: energy,
            miles: miles,
            vehicleId: vehicleId,
            vehicleDisplayName: getVehicleDisplayName(vehicleId),
            confidence: confidence,
            source: (confidence > 0) ? 'classifier' : 'manual',
            location: 'Home'  // Only one location for now (home charger)
        };
    }

    function convertToLocalTime(utcDate) {
        /**
         * Convert UTC date to America/Los_Angeles time
         * 
         * NOTE: DST transitions may cause display issues on March 2nd and November 1st
         * See KNOWN_ISSUES.md for details on daylight saving time edge cases
         */
        return new Date(utcDate.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }));
    }

    function applyFilters() {
        updateDisplay();
    }

    function changeView(view) {
        currentView = view;
        currentDate = new Date(); // Reset to today
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.view === view) btn.classList.add('active');
        });
        updateDisplay();
    }

    function previousPeriod() {
        if (currentView === 'day') {
            currentDate.setDate(currentDate.getDate() - 1);
        } else if (currentView === 'month') {
            currentDate.setMonth(currentDate.getMonth() - 1);
        } else {
            currentDate.setFullYear(currentDate.getFullYear() - 1);
        }
        updateDisplay();
    }

    function nextPeriod() {
        if (currentView === 'day') {
            currentDate.setDate(currentDate.getDate() + 1);
        } else if (currentView === 'month') {
            currentDate.setMonth(currentDate.getMonth() + 1);
        } else {
            currentDate.setFullYear(currentDate.getFullYear() + 1);
        }
        updateDisplay();
    }

    function getFilteredSessions() {
        const vehicleFilter = document.getElementById('vehicle-filter').value;
        const metricFilter = document.getElementById('metric-filter').value;

        return allSessions.filter(session => {
            if (vehicleFilter !== 'all' && session.vehicleId !== vehicleFilter) {
                return false;
            }

            // Check if session overlaps with current period
            const sessionInPeriod = isSessionInPeriod(session);
            return sessionInPeriod;
        });
    }

    function isSessionInPeriod(session) {
        const start = session.startTime;
        const end = session.endTime;


        let periodStart, periodEnd;

        if (currentView === 'day') {
            periodStart = new Date(currentDate);
            periodStart.setHours(0, 0, 0, 0);
            periodEnd = new Date(currentDate);
            periodEnd.setHours(23, 59, 59, 999);
        } else if (currentView === 'month') {
            periodStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            periodEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0, 23, 59, 59, 999);
        } else {
            periodStart = new Date(currentDate.getFullYear(), 0, 1);
            periodEnd = new Date(currentDate.getFullYear(), 11, 31, 23, 59, 59, 999);
        }

        // Now standard overlap logic works perfectly
        return start <= periodEnd && end >= periodStart;
    }

    function updateDisplay() {
        const filtered = getFilteredSessions();
        const metric = document.getElementById('metric-filter').value;

        // Update period label
        updatePeriodLabel();

        // Update navigation buttons
        document.getElementById('prev-btn').disabled = false;
        document.getElementById('next-btn').disabled = new Date() < getNextPeriodStart();

        // Calculate stats
        const stats = calculateStats(filtered, metric);
        updateStats(stats, metric);

        // Update chart
        updateChart(filtered, metric);

        // Update table
        updateSessionsTable(filtered);
    }

    function updatePeriodLabel() {
        let label = '';
        if (currentView === 'day') {
            label = currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric', year: 'numeric' });
        } else if (currentView === 'month') {
            label = currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        } else {
            label = currentDate.getFullYear().toString();
        }
        document.getElementById('period-label').textContent = label;
    }

    function getNextPeriodStart() {
        const next = new Date(currentDate);
        if (currentView === 'day') {
            next.setDate(next.getDate() + 1);
        } else if (currentView === 'month') {
            next.setMonth(next.getMonth() + 1);
        } else {
            next.setFullYear(next.getFullYear() + 1);
        }
        return next;
    }

    function calculateStats(sessions, metric) {
        let totalEnergy = 0, totalMiles = 0, totalSessions = sessions.length;

        sessions.forEach(s => {
            totalEnergy += s.energy || 0;
            totalMiles += s.miles || 0;
        });

        return { totalEnergy, totalMiles, totalSessions };
    }

    function updateStats(stats, metric) {
        const labels = {
            energy: ['Total Energy', 'Total Miles', 'Sessions'],
            miles: ['Total Miles', 'Total Energy', 'Sessions'],
            sessions: ['Sessions', 'Total Energy', 'Total Miles']
        };

        const values = {
            energy: [
                stats.totalEnergy.toFixed(1) + ' kWh',
                stats.totalMiles.toFixed(0) + ' mi',
                stats.totalSessions.toString()
            ],
            miles: [
                stats.totalMiles.toFixed(0) + ' mi',
                stats.totalEnergy.toFixed(1) + ' kWh',
                stats.totalSessions.toString()
            ],
            sessions: [
                stats.totalSessions.toString(),
                stats.totalEnergy.toFixed(1) + ' kWh',
                stats.totalMiles.toFixed(0) + ' mi'
            ]
        };

        const mapping = { energy: 0, miles: 1, sessions: 0 };
        document.getElementById('stat1-label').textContent = labels[metric][0];
        document.getElementById('stat1-value').textContent = values[metric][0];
        document.getElementById('stat2-label').textContent = labels[metric][1];
        document.getElementById('stat2-value').textContent = values[metric][1];
        document.getElementById('stat3-label').textContent = labels[metric][2];
        document.getElementById('stat3-value').textContent = values[metric][2];
    }

    function updateChart(sessions, metric) {
        const ctx = document.getElementById('sessionChart').getContext('2d');

        let labels, datasets;

        if (currentView === 'day') {
            // Hourly breakdown for current day
            labels = Array.from({ length: 24 }, (_, i) => `${i}:00`);
            const vehicleFilter = document.getElementById('vehicle-filter').value;

            // Group sessions by hour
            const hourlyData = {};
            sessions.forEach(s => {
                const hour = s.localStartTime.getHours();
                if (!hourlyData[hour]) hourlyData[hour] = [];
                hourlyData[hour].push(s);
            });

            const data = labels.map((_, hour) => {
                const hourSessions = hourlyData[hour] || [];
                if (metric === 'energy') {
                    return hourSessions.reduce((sum, s) => sum + s.energy, 0);
                } else if (metric === 'miles') {
                    return hourSessions.reduce((sum, s) => sum + s.miles, 0);
                } else {
                    return hourSessions.length;
                }
            });

            datasets = [{
                label: metric === 'energy' ? 'Energy (kWh)' : metric === 'miles' ? 'Miles' : 'Sessions',
                data: data,
                backgroundColor: 'rgba(102, 126, 234, 0.6)',
                borderColor: 'rgba(102, 126, 234, 1)',
                borderWidth: 1
            }];
        } else if (currentView === 'month') {
            // Daily breakdown for current month
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();

            labels = Array.from({ length: daysInMonth }, (_, i) => (i + 1).toString());

            const dailyData = {};
            sessions.forEach(s => {
                const day = s.localStartTime.getDate();
                if (s.localStartTime.getMonth() === month && s.localStartTime.getFullYear() === year) {
                    if (!dailyData[day]) dailyData[day] = [];
                    dailyData[day].push(s);
                }
            });

            const data = labels.map((_, i) => {
                const day = i + 1;
                const daySessions = dailyData[day] || [];
                if (metric === 'energy') {
                    return daySessions.reduce((sum, s) => sum + s.energy, 0);
                } else if (metric === 'miles') {
                    return daySessions.reduce((sum, s) => sum + s.miles, 0);
                } else {
                    return daySessions.length;
                }
            });

            datasets = [{
                label: metric === 'energy' ? 'Energy (kWh)' : metric === 'miles' ? 'Miles' : 'Sessions',
                data: data,
                backgroundColor: 'rgba(102, 126, 234, 0.6)',
                borderColor: 'rgba(102, 126, 234, 1)',
                borderWidth: 1
            }];
        } else {
            // Monthly breakdown for current year
            labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            const monthlyData = {};
            sessions.forEach(s => {
                if (s.localStartTime.getFullYear() === currentDate.getFullYear()) {
                    const month = s.localStartTime.getMonth();
                    if (!monthlyData[month]) monthlyData[month] = [];
                    monthlyData[month].push(s);
                }
            });

            const data = Array.from({ length: 12 }, (_, month) => {
                const monthSessions = monthlyData[month] || [];
                if (metric === 'energy') {
                    return monthSessions.reduce((sum, s) => sum + s.energy, 0);
                } else if (metric === 'miles') {
                    return monthSessions.reduce((sum, s) => sum + s.miles, 0);
                } else {
                    return monthSessions.length;
                }
            });

            datasets = [{
                label: metric === 'energy' ? 'Energy (kWh)' : metric === 'miles' ? 'Miles' : 'Sessions',
                data: data,
                backgroundColor: 'rgba(102, 126, 234, 0.6)',
                borderColor: 'rgba(102, 126, 234, 1)',
                borderWidth: 1
            }];
        }

        if (chart) chart.destroy();

        chart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: metric === 'energy' ? 'Energy (kWh)' : metric === 'miles' ? 'Miles' : 'Count'
                        }
                    }
                }
            }
        });
    }

    function updateSessionsTable(sessions) {
        const tbody = document.getElementById('sessions-tbody');

        if (sessions.length === 0) {
            tbody.innerHTML = '<tr><td class="no-data" colspan="6">No sessions for this period</td></tr>';
            return;
        }

        // Sort by start time descending
        const sorted = [...sessions].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));

        tbody.innerHTML = sorted.map(s => {
            let vehicleCell = '';
            if (s.vehicleId === 'unknown') {
                vehicleCell = 'Unknown';
            } else if (s.source === 'manual') {
                vehicleCell = `<em>${s.vehicleDisplayName}</em>`;
            } else if (s.source === 'classifier') {
                // Color code confidence: green (>=0.8), yellow (0.5-0.79), red (<0.5)
                let confColor = '';
                if (typeof s.confidence === 'number') {
                    if (s.confidence >= 0.8) confColor = 'style="color:#228B22;font-weight:bold"';
                    else if (s.confidence >= 0.5) confColor = 'style="color:#b59f00;font-weight:bold"';
                    else confColor = 'style="color:#b22222;font-weight:bold"';
                }
                vehicleCell = `<em>${s.vehicleDisplayName}</em> <span ${confColor}>(${Math.round((s.confidence || 0) * 100)}%)</span>`;
            } else {
                vehicleCell = `<em>${s.vehicleDisplayName}</em>`;
            }

            let durationDisplay;
            let rowStyle = '';

            if (s.isActive) {
                // Use formatDuration here
                durationDisplay = `<span style="color:#228B22; font-weight:bold">${formatDuration(s.duration)} (Active)</span>`;
            } else if (s.isZombie) {
                durationDisplay = '<span style="color:#cc0000; font-size:0.9em">DATA ERR</span>';
                rowStyle = 'style="background-color: #fff0f0"'; 
            } else {
                // And use it here
                durationDisplay = formatDuration(s.duration);
            }
            
            return `
    <tr ${rowStyle}>
        <td>${formatDateTime(s.localStartTime)}</td>
        <td>${vehicleCell}</td>
        <td>${s.energy.toFixed(1)}</td>
        <td>${s.miles.toFixed(1)}</td>
        <td>${durationDisplay}</td>
        <td>${s.location}</td>
    </tr>
`;
        }).join('');
    }

    function formatDuration(minutes) {
        if (!minutes) return '—';
        const h = Math.floor(minutes / 60);
        const m = minutes % 60;

        // If less than an hour, just show minutes (e.g. "45m")
        if (h === 0) return `${m}m`;

        // Otherwise show hours and minutes (e.g. "5h 45m")
        // The padStart ensures "5h 05m" instead of "5h 5m" for better alignment
        return `${h}h ${m.toString().padStart(2, '0')}m`;
    }

    function formatDateTime(date) {
        return date.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    // Initialize
    async function init() {
        await discoverSessions();
        updateDisplay();
    }

    init();
</script>